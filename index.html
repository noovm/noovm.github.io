<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>noo vm - Interactive Cybersecurity Lab Platform</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root{
            --primary:#0f172a; --secondary:#1e293b; --accent:#06b6d4; --accent-glow:rgba(6,182,212,0.3);
            --success:#10b981; --danger:#ef4444; --warning:#f59e0b;
            --text-primary:#f1f5f9; --text-secondary:#cbd5e1; --border:#334155;
        }
        html,body{height:100%;width:100%;overflow:hidden}
        body{
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: linear-gradient(135deg,var(--primary) 0%, #0a0e27 100%);
            color:var(--text-primary); line-height:1.6;
        }
        .container{display:flex;height:100vh;gap:0}
        .sidebar{width:320px;background:var(--secondary);border-right:1px solid var(--border);display:flex;flex-direction:column;padding:20px;overflow-y:auto;box-shadow:inset -10px 0 20px rgba(0,0,0,.3)}
        .logo{font-size:24px;font-weight:bold;margin-bottom:30px;background:linear-gradient(135deg,var(--accent),#06d4ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;letter-spacing:2px;text-transform:uppercase;text-align:center}
        .section-title{font-size:11px;text-transform:uppercase;letter-spacing:1.5px;color:var(--accent);margin-top:25px;margin-bottom:12px;font-weight:600}
        .difficulty-selector,.topic-selector{display:flex;flex-direction:column;gap:8px}
        .os-selector{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;padding-left:12px}
        .btn{padding:10px 14px;border:1px solid var(--border);background:transparent;color:var(--text-primary);cursor:pointer;border-radius:4px;font-family:inherit;font-size:12px;transition:all .3s;text-transform:uppercase;letter-spacing:.5px;font-weight:500}
        .btn:hover{border-color:var(--accent);background:rgba(6,182,212,.08);box-shadow:0 0 10px var(--accent-glow)}
        .btn.active{background:var(--accent);color:var(--primary);border-color:var(--accent);box-shadow:0 0 20px var(--accent-glow)}
        .btn-primary{margin-top:20px;background:var(--accent);color:var(--primary);border:none;font-weight:bold;padding:12px;font-size:13px}
        .btn-primary:hover{background:#00a4cc;box-shadow:0 0 25px var(--accent-glow)}
        .progress-section{margin-top:30px;padding:15px;background:rgba(6,182,212,.05);border:1px solid var(--border);border-radius:4px}
        .progress-bar{width:100%;height:8px;background:var(--secondary);border-radius:2px;margin-top:8px;overflow:hidden;border:1px solid var(--border)}
        .progress-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--success));transition:width .5s ease}
        .stats{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:15px;font-size:11px}
        .stat-item{padding:8px;background:rgba(15,23,42,.5);border:1px solid var(--border);border-radius:4px;text-align:center}
        .stat-value{font-size:16px;font-weight:bold;color:var(--accent)}
        .main-content{flex:1;display:flex;flex-direction:column;overflow:hidden}
        .header{background:var(--secondary);border-bottom:1px solid var(--border);padding:20px;box-shadow:0 2px 10px rgba(0,0,0,.3)}
        .header-title{font-size:18px;font-weight:bold;color:var(--accent);margin-bottom:5px}
        .header-subtitle{font-size:12px;color:var(--text-secondary)}
        .header-status{font-size:11px;color:var(--warning);margin-top:4px}
        .header-stats{display:flex;gap:10px;margin-top:6px;flex-wrap:wrap}
        .header-stat{font-size:11px;color:var(--text-secondary);border:1px solid var(--border);padding:4px 8px;border-radius:4px;background:rgba(15,23,42,.5)}
        .header-progress{margin-top:6px;height:6px;background:var(--primary);border:1px solid var(--border);border-radius:3px;overflow:hidden}
        .header-progress-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),var(--success));transition:width .25s ease}
        .header-actions{display:flex;align-items:center;gap:12px}
        .target-info{font-size:11px;color:var(--success);border:1px solid var(--success);padding:6px 10px;border-radius:4px;background:rgba(16,185,129,.08)}
        .section-info{font-size:11px;color:var(--accent);border:1px solid var(--accent);padding:6px 10px;border-radius:4px;background:rgba(6,182,212,.08)}
        .mobile-toggle{display:inline-flex}
        .terminal-container{flex:1;display:flex;flex-direction:column;overflow:hidden}
        .terminal{flex:1;background:var(--primary);padding:20px;overflow-y:auto;font-size:13px;border:1px solid var(--border);margin:20px;margin-bottom:0;border-radius:4px;box-shadow:inset 0 2px 10px rgba(0,0,0,.5)}
        .terminal-line{margin-bottom:8px;word-wrap:break-word;animation:slideIn .3s ease-out}
        @keyframes slideIn{from{opacity:0;transform:translateX(-10px)}to{opacity:1;transform:translateX(0)}}
        .prompt{color:var(--accent);font-weight:bold}.command{color:var(--text-primary);margin-left:5px}.output{color:var(--text-secondary);margin-left:0}.error{color:var(--danger)}.success{color:var(--success)}.info{color:var(--warning)}
        .question-line{color:var(--text-primary)}
        .context-line{color:var(--success)}
        .context-note{font-size:11px;color:var(--success);opacity:.9}
        .stage-divider{border-top:2px solid var(--accent);opacity:.6;margin:6px 0}
        .hint{background:rgba(245,158,11,.1);border-left:3px solid var(--warning);padding:10px 12px;margin:10px 0;color:var(--warning);border-radius:2px}
        .input-area{padding:20px;background:var(--secondary);border-top:1px solid var(--border);display:flex;gap:10px}
        .input-wrapper{flex:1;display:flex;align-items:center;background:var(--primary);border:1px solid var(--border);border-radius:4px;padding:0 12px}
        .input-wrapper.active{border-color:var(--accent);box-shadow:0 0 15px var(--accent-glow)}
        .prompt-symbol{color:var(--accent);margin-right:8px;font-weight:bold}
        input[type="text"]{flex:1;background:transparent;border:none;color:var(--text-primary);font-family:inherit;font-size:13px;outline:none;padding:10px 0}
        input[type="text"]::placeholder{color:var(--text-secondary)}
        .btn-submit{padding:10px 20px;background:var(--accent);color:var(--primary);border:none;border-radius:4px;cursor:pointer;font-family:inherit;font-weight:bold;transition:all .3s}
        .btn-submit:hover{background:#00a4cc;box-shadow:0 0 20px var(--accent-glow)}
        .modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);justify-content:center;align-items:center;z-index:1000;backdrop-filter:blur(4px)}
        .modal.active{display:flex}.modal-content{background:var(--secondary);padding:30px;border-radius:6px;border:1px solid var(--border);max-width:500px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,.5)}
        .modal-title{font-size:20px;color:var(--accent);margin-bottom:15px;font-weight:bold}.modal-text{color:var(--text-secondary);margin-bottom:20px;line-height:1.8}
        .modal-buttons{display:flex;gap:10px}.hidden{display:none}
        ::-webkit-scrollbar{width:8px;height:8px} ::-webkit-scrollbar-track{background:var(--primary)} ::-webkit-scrollbar-thumb{background:var(--accent);border-radius:4px} ::-webkit-scrollbar-thumb:hover{background:#00a4cc}
        .loading{display:inline-block;color:var(--accent)} .loading::after{content:'.';animation:dots 1.5s steps(4,end) infinite}
        @keyframes dots{0%,20%{content:'.'}40%{content:'..'}60%{content:'...'}80%,100%{content:''}}

        /* Responsive layout */
        @media (max-width: 1024px) {
            .sidebar{width:280px;padding:16px}
            .header{padding:16px}
            .terminal{margin:16px;padding:16px}
            .input-area{padding:16px}
        }

        @media (max-width: 860px) {
            html,body{overflow:auto}
            .container{flex-direction:column;height:auto;min-height:100vh}
            .sidebar{width:100%;border-right:none;border-bottom:1px solid var(--border);box-shadow:none}
            .mobile-toggle{display:inline-flex}
            .main-content{width:100%}
            .os-selector{grid-template-columns:1fr 1fr 1fr}
            .difficulty-selector,.topic-selector{gap:6px}
            .header{position:sticky;top:0;z-index:5}
            .terminal{margin:12px}
            .input-area{flex-direction:column}
            .btn-submit{width:100%}
            .header-actions{flex-wrap:wrap;justify-content:flex-end}
            .target-info{order:2}
        }

        .sidebar-collapsed .sidebar{display:none}
        .sidebar-collapsed .main-content{width:100%}

        @media (max-width: 600px) {
            .logo{font-size:20px}
            .sidebar{padding:14px}
            .section-title{margin-top:18px}
            .os-selector{grid-template-columns:1fr 1fr}
            .btn{font-size:11px;padding:9px 12px}
            .header-title{font-size:16px}
            .header-subtitle{font-size:11px}
            .terminal{font-size:12px;padding:14px}
            .input-wrapper{padding:0 10px}
            input[type="text"]{font-size:12px}
            .modal-content{padding:20px}
        }

        @media (max-width: 420px) {
            .os-selector{grid-template-columns:1fr}
            .stats{grid-template-columns:1fr}
            .terminal{margin:10px}
            .input-area{padding:12px}
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- SIDEBAR -->
        <div class="sidebar">
            <div class="logo">noo vm</div>

            <div>
                <div class="section-title">Operating System</div>
                <div class="os-selector">
                    <button class="btn active" data-os="linux">üêß Linux</button>
                    <button class="btn" data-os="windows">ü™ü Windows</button>
                    <!-- <button class="btn" data-os="macos">üçé macOS</button> -->
                </div>
            </div>

            <div>
                <div class="section-title">Guidance Mode</div>
                <div class="difficulty-selector">
                    <button class="btn active" data-guidance="guided">Guided (extra hints)</button>
                    <button class="btn" data-guidance="challenge">Challenge (minimal hints)</button>
                </div>
            </div>

            <div>
                <div class="section-title">Topic</div>
                <div class="topic-selector">
                    <button class="btn active" data-topic="network">Network Penetration</button>
                    <button class="btn" data-topic="privilege">Privilege Escalation</button>
                    <button class="btn" data-topic="web">Web Security</button>
                    <button class="btn" data-topic="postex">Post-Exploitation</button>
                    <button class="btn" data-topic="crypto">Cryptography</button>
                    <button class="btn" data-topic="logs">Log Analysis</button>
                    <button class="btn" data-topic="perms">File Permissions</button>
                    <button class="btn" data-topic="proc">Process & Service Recon</button>
                    <button class="btn" data-topic="audit">User & Access Auditing</button>
                    <button class="btn" data-topic="nettrouble">Network Troubleshooting</button>
                    <button class="btn" data-topic="webbasics">Web App Basics</button>
                    <button class="btn" data-topic="filesearch">File Search & Discovery</button>
                    <button class="btn" data-topic="perf">System Performance</button>
                    <button class="btn hidden" data-topic="winrecon">Windows Local Recon</button>
                    <button class="btn hidden" data-topic="ad">Active Directory Basics</button>
                    <button class="btn hidden" data-topic="wireless">Wireless Recon</button>
                    <!--
                    <button class="btn" data-topic="other">Other</button>
                    -->
                </div>
            </div>

            <div id="startMachineSection" class="hidden">
                <button class="btn btn-primary" id="startMachineBtn">üñ•Ô∏è Start Machine</button>
            </div>

            <div class="progress-section hidden" id="progressSection">
                <div class="section-title">Progress</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width:0%"></div>
                </div>
                <div style="margin-top:8px;font-size:11px;color:var(--text-secondary);">
                    Stage <span id="currentStage">0</span> / <span id="totalStages">8</span>
                </div>
                <div class="stats">
                    <div class="stat-item">
                        <div style="color:var(--text-secondary)">Time</div>
                        <div class="stat-value" id="elapsed">0:00</div>
                    </div>
                    <div class="stat-item">
                        <div style="color:var(--text-secondary)">Commands</div>
                        <div class="stat-value" id="cmdCount">0</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- MAIN CONTENT -->
        <div class="main-content">
            <div class="header">
                <div style="display:flex;justify-content:space-between;align-items:center">
                    <div>
                        <div class="header-title" id="headerTitle">Welcome to noo vm</div>
                        <div class="header-subtitle" id="headerSubtitle">Select OS, difficulty, and topic to start</div>
                        <div class="header-status hidden" id="headerStatus"></div>
                        <div class="header-progress hidden" id="headerProgress">
                            <div class="header-progress-fill" id="headerProgressFill"></div>
                        </div>
                        <div class="header-stats hidden" id="headerStats">
                            <div class="header-stat" id="headerStageStat">Stage: 0/0</div>
                            <div class="header-stat" id="headerTimeStat">Time: 0:00</div>
                            <div class="header-stat" id="headerCmdStat">Commands: 0</div>
                        </div>
                    </div>
                    <div class="header-actions">
                        <div class="target-info hidden" id="targetInfo"></div>
                        <div class="section-info hidden" id="sectionInfo"></div>
                        <button class="btn mobile-toggle" id="mobileToggleBtn" style="padding:8px 12px;font-size:11px">‚ò∞ Menu</button>
                        <button class="btn" id="regenerateBtn" style="padding:8px 12px;font-size:11px">‚Üª Regenerate</button>
                        <button class="btn" id="settingsBtn" style="padding:8px 12px;font-size:11px">‚öôÔ∏è Settings</button>
                    </div>
                </div>
            </div>

            <div class="terminal-container">
                <div class="terminal" id="terminal">
                    <div class="terminal-line" style="color:var(--accent)">Welcome to noo vm - Interactive Cybersecurity Lab</div>
                    <div class="terminal-line" style="color:var(--text-secondary)">Select your difficulty and topic from the left panel</div>
                    <div class="terminal-line" style="color:var(--text-secondary);margin-top:15px">Type commands as if you're on a real system. Each scenario builds progressively.</div>
                </div>

                <form class="input-area" autocomplete="off" data-lpignore="true" data-1p-ignore="true">
                    <div class="input-wrapper" id="inputWrapper">
                        <span class="prompt-symbol">$</span>
                        <input
                            type="text"
                            id="commandInput"
                            name="command"
                            placeholder="Enter command..."
                            autocomplete="off"
                            autocorrect="off"
                            autocapitalize="off"
                            spellcheck="false"
                            inputmode="text"
                            data-form-type="other"
                            data-lpignore="true"
                            data-1p-ignore="true"
                            disabled
                        />
                    </div>
                    <button class="btn-submit" id="submitBtn" disabled>Execute</button>
                </form>
            </div>
        </div>
    </div>

    <!-- SETTINGS MODAL -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-title">‚öôÔ∏è Settings</div>
            <div class="modal-text" style="font-size:12px;margin-bottom:15px">
                Enter your Hugging Face API token to enable AI scenario generation.
                <br /><br />
                <strong>Step-by-step:</strong>
                <br />1) Create a free Hugging Face account.
                <br />2) Go to <a href="https://huggingface.co/settings/tokens" target="_blank" rel="noopener noreferrer" style="color:var(--accent);text-decoration:underline">https://huggingface.co/settings/tokens</a>
                <br />3) Click "New token"
                <br />4) Click "Read"
                <br />5) Click "Create Token"
                <br />6) Copy the token (starts with hf_) and paste it here.
                <br /><br />
                <strong>Note:</strong> Your API key is stored locally on your device.
            </div>
            <input type="password" id="hfTokenInput" placeholder="Enter HF_TOKEN..." style="width:100%;padding:10px;margin-bottom:15px;background:var(--primary);border:1px solid var(--border);color:var(--text-primary);border-radius:4px;font-family:inherit" />
            <div class="modal-buttons">
                <button class="btn" style="flex:1;" onclick="closeSettings()">Cancel</button>
                <button class="btn btn-primary" style="flex:1;" id="saveTokenBtn">Save Token</button>
            </div>
        </div>
    </div>

    <!-- HINT MODAL -->
    <div class="modal" id="hintModal">
        <div class="modal-content">
            <div class="modal-title">üí° Hint</div>
            <div class="modal-text" id="hintText"></div>
            <div class="modal-buttons">
                <button class="btn" style="flex:1;" onclick="closeHint()">Close</button>
                <button class="btn btn-primary" style="flex:1;" onclick="nextHint()">Next Hint</button>
            </div>
        </div>
    </div>

    <!-- VICTORY MODAL -->
    <div class="modal" id="victoryModal">
        <div class="modal-content">
            <div class="modal-title">üéâ Scenario Complete!</div>
            <div class="modal-text" id="victoryText"></div>
            <div class="modal-buttons">
                <button class="btn btn-primary" style="flex:1;" onclick="location.reload()">New Scenario</button>
            </div>
        </div>
    </div>

    <script>
    const TOPIC_MAP = {
        'network': 'network_penetration',
        'privilege': 'privilege_escalation',
        'web': 'web_security',
        'postex': 'post_exploitation',
        'crypto': 'cryptography',
        'logs': 'log_analysis',
        'perms': 'file_permissions',
        'proc': 'process_service_recon',
        'audit': 'user_access_auditing',
        'nettrouble': 'network_troubleshooting',
        'webbasics': 'web_app_basics',
        'filesearch': 'file_search_discovery',
        'perf': 'system_performance',
        'winrecon': 'windows_local_recon',
        'ad': 'active_directory_basics',
        'wireless': 'wireless_recon'
    };

    const NETWORK_SECTIONS = [
        'whois',
        'nslookup',
        'dig',
        'ping',
        'traceroute',
        'telnet',
        'netcat',
        'nmap basic port scan (tcp connect scan)',
        'nmap basic port scan (tcp SYN scan)',
        'nmap basic port scan (udp port scan)'
    ];

    const PRIV_ESC_SECTIONS = [
        'sudo -l',
        'id',
        'groups',
        'find',
        'ps aux',
        'crontab',
        'env',
        'SUID binaries',
        'Misconfigured permissions'
    ];

    const WEB_SECTIONS = [
        'directory brute force',
        'basic SQLi',
        'basic XSS',
        'HTTP header inspection',
        'robots.txt',
        'parameter fuzzing'
    ];

    const POSTEX_SECTIONS = [
        'whoami/hostname',
        'system info',
        'network discovery',
        'user enumeration',
        'file search',
        'process inspection'
    ];

    const CRYPTO_SECTIONS = [
        'hash identification',
        'base64 encode/decode',
        'openssl md5/sha',
        'salted hash check',
        'simple Caesar'
    ];

    const AD_SECTIONS = [
        'whoami /all',
        'net user',
        'net group',
        'ipconfig /all',
        'systeminfo'
    ];

    const WIRELESS_SECTIONS = [
        'monitor mode',
        'airodump basics',
        'handshake capture',
        'channel hopping'
    ];

    const LOGS_SECTIONS = [
        'journalctl',
        'auth.log',
        'syslog',
        'last',
        'lastlog',
        'grep'
    ];

    const PERMS_SECTIONS = [
        'ls -l',
        'chmod',
        'chown',
        'umask',
        'getfacl',
        'setfacl'
    ];

    const PROC_SECTIONS = [
        'ps aux',
        'systemctl',
        'ss -tulpen',
        'netstat',
        'lsof -i'
    ];

    const WIN_RECON_SECTIONS = [
        'whoami',
        'systeminfo',
        'tasklist',
        'netstat -ano',
        'ipconfig /all'
    ];

    const AUDIT_SECTIONS = [
        'id',
        'groups',
        'last',
        'lastlog',
        'getent passwd',
        'sudo -l'
    ];

    const NET_TROUBLE_SECTIONS = [
        'ip a',
        'ip r',
        'ping',
        'traceroute',
        'mtr',
        'ss -tulpen'
    ];

    const WEB_BASICS_SECTIONS = [
        'curl',
        'httpie',
        'headers',
        'cookies',
        'GET vs POST'
    ];

    const FILE_SEARCH_SECTIONS = [
        'find',
        'locate',
        'grep',
        'awk',
        'ripgrep'
    ];

    const PERF_SECTIONS = [
        'top',
        'htop',
        'free -m',
        'df -h',
        'du -sh'
    ];

    function stagesForDifficulty(d) {
        switch (d) {
            case 'beginner': return 4;
            case 'intermediate': return 5;
            case 'advanced': return 6;
            case 'expert': return 7;
            default: return 4;
        }
    }

    function sanitizeModelText(raw) {
        if (!raw) return '';
        let t = String(raw);
        t = t.replace(/```[\s\S]*?```/g, match => match.replace(/```/g, ''));
        t = t.replace(/`/g, '');
        if (t.length > 18000) t = t.slice(0, 18000);
        return t;
    }

    function buildAIPrompt(difficulty, topic, os) {
        const normalizedTopic = TOPIC_MAP[topic] || topic;
        const isNetworkLinux = os === 'linux' && normalizedTopic === 'network_penetration';
        const isPrivilegeLinux = os === 'linux' && normalizedTopic === 'privilege_escalation';
        const isWebLinux = os === 'linux' && normalizedTopic === 'web_security';
        const isPostexLinux = os === 'linux' && normalizedTopic === 'post_exploitation';
        const isCryptoLinux = os === 'linux' && normalizedTopic === 'cryptography';
        const isLogsLinux = os === 'linux' && normalizedTopic === 'log_analysis';
        const isPermsLinux = os === 'linux' && normalizedTopic === 'file_permissions';
        const isProcLinux = os === 'linux' && normalizedTopic === 'process_service_recon';
        const isAuditLinux = os === 'linux' && normalizedTopic === 'user_access_auditing';
        const isNetTroubleLinux = os === 'linux' && normalizedTopic === 'network_troubleshooting';
        const isWebBasicsLinux = os === 'linux' && normalizedTopic === 'web_app_basics';
        const isFileSearchLinux = os === 'linux' && normalizedTopic === 'file_search_discovery';
        const isPerfLinux = os === 'linux' && normalizedTopic === 'system_performance';
        const isWinReconWindows = os === 'windows' && normalizedTopic === 'windows_local_recon';
        const isAdWindowsAdvanced = os === 'windows' && (difficulty === 'advanced' || difficulty === 'expert') && normalizedTopic === 'active_directory_basics';
        const isWirelessAdvanced = (difficulty === 'advanced' || difficulty === 'expert') && normalizedTopic === 'wireless_recon';
        const numberOfStages = stagesForDifficulty(difficulty);

        if (isNetworkLinux) {
            const chosenSection = pickNetworkSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational scenario.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Choose one section from the list",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-c 4","192.168.1.10"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isPrivilegeLinux) {
            const chosenSection = pickPrivilegeSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational privilege escalation scenario for Linux.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-l"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isWebLinux) {
            const chosenSection = pickWebSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational web security scenario for Linux.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-I"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isPostexLinux) {
            const chosenSection = pickPostexSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational post-exploitation scenario for Linux.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-a"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isCryptoLinux) {
            const chosenSection = pickCryptoSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational cryptography basics scenario for Linux.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-base64"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isLogsLinux) {
            const chosenSection = pickLogsSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational log analysis scenario for Linux.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-u"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isPermsLinux) {
            const chosenSection = pickPermsSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational file permissions scenario for Linux.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-l"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isProcLinux) {
            const chosenSection = pickProcSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational process and service recon scenario for Linux.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-tulpen"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isWinReconWindows) {
            const chosenSection = pickWinReconSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational Windows local reconnaissance scenario.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["/all"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isAuditLinux) {
            const chosenSection = pickAuditSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational Linux user and access auditing scenario.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-l"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isNetTroubleLinux) {
            const chosenSection = pickNetTroubleSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational Linux network troubleshooting scenario.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-c"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isWebBasicsLinux) {
            const chosenSection = pickWebBasicsSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational web app basics scenario for Linux.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-I"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isFileSearchLinux) {
            const chosenSection = pickFileSearchSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational file search and discovery scenario for Linux.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-name"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isPerfLinux) {
            const chosenSection = pickPerfSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational Linux system performance scenario.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-h"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isAdWindowsAdvanced) {
            const chosenSection = pickAdSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational Active Directory basics scenario for Windows.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["/all"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        if (isWirelessAdvanced) {
            const chosenSection = pickWirelessSection();
            const sessionId = Math.random().toString(36).slice(2);
            state.currentSection = chosenSection;
            return `You are an expert cybersecurity training scenario generator. Create a ${numberOfStages}-stage, educational wireless reconnaissance (theory only) scenario.

Use ONLY this section for all stages: ${chosenSection}
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.1.10",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "topic": "Use only the chosen section",
      "objective": "Objective",
      "question": "Question prompt",
      "answer": "Command the learner should run",
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["-w"],
      "hints": ["hint1", "hint2", "hint3"]
    }
  ]
}

Create ${numberOfStages} stages. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]).
Keep each answer as a single command.`;
        }

        const sessionId = Math.random().toString(36).slice(2);
        state.currentSection = null;
        return `You are an expert cybersecurity training scenario generator. Create an interactive, educational cybersecurity challenge scenario.
Session ID (for variation): ${sessionId}
Guidance mode: ${state.guidanceMode}

Return ONLY a valid JSON object with this exact structure (no markdown, no explanations):
{
  "title": "Scenario Name",
  "description": "Description",
  "osType": "${os}",
  "difficulty": "${difficulty}",
  "topic": "${normalizedTopic}",
  "numberOfStages": ${numberOfStages},
  "scenarioBackground": "Background",
  "targetIP": "192.168.x.x",
  "stages": [
    {
      "stageNumber": 1,
      "name": "Stage Name",
      "objective": "Objective",
      "expectedCommands": ["cmd1", "cmd2"],
      "commandVariations": [{"command": "tool", "variations": ["alt1"], "description": "desc"}],
      "commandExplanation": "Explain what the command does",
      "expectedFlags": ["flag1"],
      "hints": ["hint1", "hint2", "hint3"],
      "commonMistakes": ["mistake1"],
      "output": "expected output",
      "successCriteria": "success text",
      "securityImplications": "implications",
      "nextStageSummary": "next stage"
    }
  ],
  "metadata": {
    "estimatedDuration": "time",
    "prerequisites": ["prereq"],
    "learningOutcomes": ["outcome"],
    "realWorldApplicability": "applicability"
  }
}

Create ${numberOfStages} stages for ${difficulty} difficulty covering ${normalizedTopic}. Each stage must be linked to the previous stage's outcome (progressive chain).
For every stage, write a specific question that requires the exact answer command (include exact flags, counts, IP/port).
The answer must be exactly one command string (no alternatives, no explanation).
Include "expectedFlags" as an array of exact flags/args that must appear in the answer (e.g., ["-c 4","192.168.1.10"]). Make it realistic and educational.`;
    }

    const CF_BASE = "https://noovm.uthnote.workers.dev";

    let state = {
        difficulty: 'beginner',
        guidanceMode: 'guided',
        topic: 'network',
        os: 'linux',
        scenario: null,
        currentStage: 0,
        commandCount: 0,
        startTime: null,
        active: false,
        completedStages: [],
        hints: [],
        currentHintIndex: 0,
        isAIGenerated: false,
        isFallback: false,
        wrongAttempts: {},
        revealEnabled: {},
        lastSection: null,
        currentSection: null,
        answerRevealed: {},
        loadingPhase: false,
        progressTimer: null,
        progressStart: null
    };

    function pickNetworkSection() {
        if (!NETWORK_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_network');
        state.lastSection = stored || state.lastSection;
        if (NETWORK_SECTIONS.length === 1) {
            state.lastSection = NETWORK_SECTIONS[0];
            localStorage.setItem('last_section_network', state.lastSection);
            return NETWORK_SECTIONS[0];
        }
        let pick = NETWORK_SECTIONS[Math.floor(Math.random() * NETWORK_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (NETWORK_SECTIONS.indexOf(pick) + 1) % NETWORK_SECTIONS.length;
            pick = NETWORK_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_network', state.lastSection);
        return pick;
    }

    function pickPrivilegeSection() {
        if (!PRIV_ESC_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_privilege');
        state.lastSection = stored || state.lastSection;
        if (PRIV_ESC_SECTIONS.length === 1) {
            state.lastSection = PRIV_ESC_SECTIONS[0];
            localStorage.setItem('last_section_privilege', state.lastSection);
            return PRIV_ESC_SECTIONS[0];
        }
        let pick = PRIV_ESC_SECTIONS[Math.floor(Math.random() * PRIV_ESC_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (PRIV_ESC_SECTIONS.indexOf(pick) + 1) % PRIV_ESC_SECTIONS.length;
            pick = PRIV_ESC_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_privilege', state.lastSection);
        return pick;
    }

    function pickWebSection() {
        if (!WEB_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_web');
        state.lastSection = stored || state.lastSection;
        if (WEB_SECTIONS.length === 1) {
            state.lastSection = WEB_SECTIONS[0];
            localStorage.setItem('last_section_web', state.lastSection);
            return WEB_SECTIONS[0];
        }
        let pick = WEB_SECTIONS[Math.floor(Math.random() * WEB_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (WEB_SECTIONS.indexOf(pick) + 1) % WEB_SECTIONS.length;
            pick = WEB_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_web', state.lastSection);
        return pick;
    }

    function pickPostexSection() {
        if (!POSTEX_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_postex');
        state.lastSection = stored || state.lastSection;
        if (POSTEX_SECTIONS.length === 1) {
            state.lastSection = POSTEX_SECTIONS[0];
            localStorage.setItem('last_section_postex', state.lastSection);
            return POSTEX_SECTIONS[0];
        }
        let pick = POSTEX_SECTIONS[Math.floor(Math.random() * POSTEX_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (POSTEX_SECTIONS.indexOf(pick) + 1) % POSTEX_SECTIONS.length;
            pick = POSTEX_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_postex', state.lastSection);
        return pick;
    }

    function pickCryptoSection() {
        if (!CRYPTO_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_crypto');
        state.lastSection = stored || state.lastSection;
        if (CRYPTO_SECTIONS.length === 1) {
            state.lastSection = CRYPTO_SECTIONS[0];
            localStorage.setItem('last_section_crypto', state.lastSection);
            return CRYPTO_SECTIONS[0];
        }
        let pick = CRYPTO_SECTIONS[Math.floor(Math.random() * CRYPTO_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (CRYPTO_SECTIONS.indexOf(pick) + 1) % CRYPTO_SECTIONS.length;
            pick = CRYPTO_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_crypto', state.lastSection);
        return pick;
    }

    function pickAdSection() {
        if (!AD_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_ad');
        state.lastSection = stored || state.lastSection;
        if (AD_SECTIONS.length === 1) {
            state.lastSection = AD_SECTIONS[0];
            localStorage.setItem('last_section_ad', state.lastSection);
            return AD_SECTIONS[0];
        }
        let pick = AD_SECTIONS[Math.floor(Math.random() * AD_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (AD_SECTIONS.indexOf(pick) + 1) % AD_SECTIONS.length;
            pick = AD_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_ad', state.lastSection);
        return pick;
    }

    function pickWirelessSection() {
        if (!WIRELESS_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_wireless');
        state.lastSection = stored || state.lastSection;
        if (WIRELESS_SECTIONS.length === 1) {
            state.lastSection = WIRELESS_SECTIONS[0];
            localStorage.setItem('last_section_wireless', state.lastSection);
            return WIRELESS_SECTIONS[0];
        }
        let pick = WIRELESS_SECTIONS[Math.floor(Math.random() * WIRELESS_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (WIRELESS_SECTIONS.indexOf(pick) + 1) % WIRELESS_SECTIONS.length;
            pick = WIRELESS_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_wireless', state.lastSection);
        return pick;
    }

    function pickLogsSection() {
        if (!LOGS_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_logs');
        state.lastSection = stored || state.lastSection;
        if (LOGS_SECTIONS.length === 1) {
            state.lastSection = LOGS_SECTIONS[0];
            localStorage.setItem('last_section_logs', state.lastSection);
            return LOGS_SECTIONS[0];
        }
        let pick = LOGS_SECTIONS[Math.floor(Math.random() * LOGS_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (LOGS_SECTIONS.indexOf(pick) + 1) % LOGS_SECTIONS.length;
            pick = LOGS_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_logs', state.lastSection);
        return pick;
    }

    function pickPermsSection() {
        if (!PERMS_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_perms');
        state.lastSection = stored || state.lastSection;
        if (PERMS_SECTIONS.length === 1) {
            state.lastSection = PERMS_SECTIONS[0];
            localStorage.setItem('last_section_perms', state.lastSection);
            return PERMS_SECTIONS[0];
        }
        let pick = PERMS_SECTIONS[Math.floor(Math.random() * PERMS_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (PERMS_SECTIONS.indexOf(pick) + 1) % PERMS_SECTIONS.length;
            pick = PERMS_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_perms', state.lastSection);
        return pick;
    }

    function pickProcSection() {
        if (!PROC_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_proc');
        state.lastSection = stored || state.lastSection;
        if (PROC_SECTIONS.length === 1) {
            state.lastSection = PROC_SECTIONS[0];
            localStorage.setItem('last_section_proc', state.lastSection);
            return PROC_SECTIONS[0];
        }
        let pick = PROC_SECTIONS[Math.floor(Math.random() * PROC_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (PROC_SECTIONS.indexOf(pick) + 1) % PROC_SECTIONS.length;
            pick = PROC_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_proc', state.lastSection);
        return pick;
    }

    function pickWinReconSection() {
        if (!WIN_RECON_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_winrecon');
        state.lastSection = stored || state.lastSection;
        if (WIN_RECON_SECTIONS.length === 1) {
            state.lastSection = WIN_RECON_SECTIONS[0];
            localStorage.setItem('last_section_winrecon', state.lastSection);
            return WIN_RECON_SECTIONS[0];
        }
        let pick = WIN_RECON_SECTIONS[Math.floor(Math.random() * WIN_RECON_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (WIN_RECON_SECTIONS.indexOf(pick) + 1) % WIN_RECON_SECTIONS.length;
            pick = WIN_RECON_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_winrecon', state.lastSection);
        return pick;
    }

    function pickAuditSection() {
        if (!AUDIT_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_audit');
        state.lastSection = stored || state.lastSection;
        if (AUDIT_SECTIONS.length === 1) {
            state.lastSection = AUDIT_SECTIONS[0];
            localStorage.setItem('last_section_audit', state.lastSection);
            return AUDIT_SECTIONS[0];
        }
        let pick = AUDIT_SECTIONS[Math.floor(Math.random() * AUDIT_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (AUDIT_SECTIONS.indexOf(pick) + 1) % AUDIT_SECTIONS.length;
            pick = AUDIT_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_audit', state.lastSection);
        return pick;
    }

    function pickNetTroubleSection() {
        if (!NET_TROUBLE_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_nettrouble');
        state.lastSection = stored || state.lastSection;
        if (NET_TROUBLE_SECTIONS.length === 1) {
            state.lastSection = NET_TROUBLE_SECTIONS[0];
            localStorage.setItem('last_section_nettrouble', state.lastSection);
            return NET_TROUBLE_SECTIONS[0];
        }
        let pick = NET_TROUBLE_SECTIONS[Math.floor(Math.random() * NET_TROUBLE_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (NET_TROUBLE_SECTIONS.indexOf(pick) + 1) % NET_TROUBLE_SECTIONS.length;
            pick = NET_TROUBLE_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_nettrouble', state.lastSection);
        return pick;
    }

    function pickWebBasicsSection() {
        if (!WEB_BASICS_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_webbasics');
        state.lastSection = stored || state.lastSection;
        if (WEB_BASICS_SECTIONS.length === 1) {
            state.lastSection = WEB_BASICS_SECTIONS[0];
            localStorage.setItem('last_section_webbasics', state.lastSection);
            return WEB_BASICS_SECTIONS[0];
        }
        let pick = WEB_BASICS_SECTIONS[Math.floor(Math.random() * WEB_BASICS_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (WEB_BASICS_SECTIONS.indexOf(pick) + 1) % WEB_BASICS_SECTIONS.length;
            pick = WEB_BASICS_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_webbasics', state.lastSection);
        return pick;
    }

    function pickFileSearchSection() {
        if (!FILE_SEARCH_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_filesearch');
        state.lastSection = stored || state.lastSection;
        if (FILE_SEARCH_SECTIONS.length === 1) {
            state.lastSection = FILE_SEARCH_SECTIONS[0];
            localStorage.setItem('last_section_filesearch', state.lastSection);
            return FILE_SEARCH_SECTIONS[0];
        }
        let pick = FILE_SEARCH_SECTIONS[Math.floor(Math.random() * FILE_SEARCH_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (FILE_SEARCH_SECTIONS.indexOf(pick) + 1) % FILE_SEARCH_SECTIONS.length;
            pick = FILE_SEARCH_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_filesearch', state.lastSection);
        return pick;
    }

    function pickPerfSection() {
        if (!PERF_SECTIONS.length) return '';
        const stored = localStorage.getItem('last_section_perf');
        state.lastSection = stored || state.lastSection;
        if (PERF_SECTIONS.length === 1) {
            state.lastSection = PERF_SECTIONS[0];
            localStorage.setItem('last_section_perf', state.lastSection);
            return PERF_SECTIONS[0];
        }
        let pick = PERF_SECTIONS[Math.floor(Math.random() * PERF_SECTIONS.length)];
        if (state.lastSection && pick === state.lastSection) {
            const idx = (PERF_SECTIONS.indexOf(pick) + 1) % PERF_SECTIONS.length;
            pick = PERF_SECTIONS[idx];
        }
        state.lastSection = pick;
        localStorage.setItem('last_section_perf', state.lastSection);
        return pick;
    }

    const fallbackScenario = {
        title: 'SQL Injection Basics',
        description: 'Learn SQL injection fundamentals via a vulnerable search endpoint',
        osType: 'linux',
        difficulty: 'beginner',
        topic: 'web_security',
        numberOfStages: 3,
        scenarioBackground: 'Target is a small internal web app with a search page vulnerable to SQLi.',
        targetIP: '192.168.56.101',
        stages: [
            {
                stageNumber: 1,
                name: 'Discovery',
                objective: 'Find the web service and confirm reachable port',
                expectedCommands: ['curl http://192.168.56.101:8080', 'wget http://192.168.56.101:8080', 'curl http://192.168.56.101:8080/'],
                commandVariations: [
                    { command: 'curl', variations: ['wget', 'curl -I', 'curl -v'], description: 'basic HTTP retrieval' }
                ],
                hints: ['Use curl/wget to fetch root page on port 8080', 'Look for HTML forms indicating search/login endpoints', 'Try curl -I to inspect headers'],
                commonMistakes: ['Missing port in URL', 'Typing http instead of http://', 'Not quoting URLs with special chars'],
                output: 'HTTP/1.1 200 OK\nContent-Type: text/html\n\n<html>\n  <title>Search Portal</title>\n  <form action="/search.php" method="GET">\n    <input name="q" placeholder="search">\n    <button type="submit">Search</button>\n  </form>\n</html>',
                successCriteria: 'Search Portal',
                securityImplications: 'Exposed search parameter could be injectable; inputs must be sanitized and parameterized.',
                nextStageSummary: 'Search form accepts q parameter ‚Äî test reflection and DB behavior.'
            },
            {
                stageNumber: 2,
                name: 'Parameter Discovery',
                objective: 'Confirm the search parameter reflects input and may be vulnerable',
                expectedCommands: ['curl "http://192.168.56.101:8080/search.php?q=test"', 'curl http://192.168.56.101:8080/search.php?q=test'],
                commandVariations: [
                    { command: 'curl "http://.../search.php?q=test"', variations: ['wget "http://.../search.php?q=test"', 'curl -G -d q=test'], description: 'invoke search endpoint' }
                ],
                hints: ['Send a test query and check response for echoed input', 'If input is echoed, attempt SQL payloads next', 'Use -G or URL encoding if shell interferes'],
                commonMistakes: ['Not quoting URLs', 'Forgetting to URL-encode special chars'],
                output: 'Search results for: test\nNo results found.',
                successCriteria: 'Search results for:',
                securityImplications: 'Reflected input suggests server-side uses input unsafely; sanitization missing.',
                nextStageSummary: 'Try a simple SQL injection payload to trigger an error or bypass.'
            },
            {
                stageNumber: 3,
                name: 'SQL Injection Test',
                objective: 'Use a simple payload to confirm SQL injection',
                expectedCommands: ["curl 'http://192.168.56.101:8080/search.php?q=\' OR \'1\'=\'1'", 'curl "http://192.168.56.101:8080/search.php?q=\' OR \'1\'=\'1"'],
                commandVariations: [
                    { command: "' OR '1'='1", variations: ["\' OR \'1\'=\'1\'", "%27+OR+%271%27%3D%271"], description: 'boolean bypass payload' }
                ],
                hints: ['Try classic OR 1=1 payload', 'Watch for SQL errors or unexpected results', 'If quotes break, try URL-encoding'],
                commonMistakes: ['Not escaping quotes on shell', 'Using wrong URL encoding'],
                output: "SQL Error: syntax error near 'OR'\nQuery: SELECT * FROM items WHERE name=' OR '1'='1'\nDatabase: MySQL 5.7.20",
                successCriteria: 'SQL Error',
                securityImplications: 'Successful injection can lead to data disclosure or authentication bypass.',
                nextStageSummary: 'If confirmed, consider extraction in a controlled advanced scenario.'
            }
        ],
        metadata: {
            estimatedDuration: '20-30 minutes',
            prerequisites: ['basic shell usage', 'HTTP fundamentals'],
            learningOutcomes: ['Recognize reflected input', 'Test simple SQLi payloads'],
            realWorldApplicability: 'Maps to many legacy webapps exposing unsanitized inputs.'
        }
    };

    function addTerminalLine(type, content) {
        const terminal = document.getElementById('terminal');
        const line = document.createElement('div');
        line.className = `terminal-line ${type}`;
        if (state.loadingPhase) line.classList.add('startup-log');
        line.innerHTML = content;
        terminal.appendChild(line);
        terminal.scrollTop = terminal.scrollHeight;
        updateHeaderStatusFromLine(content);
    }

    function clearStartupLogs() {
        document.querySelectorAll('.terminal-line.startup-log').forEach(el => el.remove());
    }

    function updateHeaderStatusFromLine(content) {
        const statusEl = document.getElementById('headerStatus');
        if (!statusEl) return;
        const text = String(content || '').replace(/<[^>]*>/g, '').trim();
        if (!text) return;
        if (text === '[*] Sending request to generation service...') {
            statusEl.textContent = '[*] Generating scenario... please wait ~5 seconds';
            statusEl.classList.remove('hidden');
            return;
        }
        if (text.startsWith('[*]') || text.startsWith('[‚úì]') || text.startsWith('[!]')) {
            statusEl.textContent = text;
            statusEl.classList.remove('hidden');
        }
    }

    function startHeaderProgress(durationMs) {
        const wrap = document.getElementById('headerProgress');
        const fill = document.getElementById('headerProgressFill');
        if (!wrap || !fill) return;
        wrap.classList.remove('hidden');
        fill.style.width = '0%';
        state.progressStart = Date.now();
        const total = durationMs || 40000;
        if (state.progressTimer) clearInterval(state.progressTimer);
        state.progressTimer = setInterval(()=>{
            const elapsed = Date.now() - state.progressStart;
            const pct = Math.min(100, Math.round((elapsed / total) * 100));
            fill.style.width = pct + '%';
            if (pct >= 100) {
                clearInterval(state.progressTimer);
                state.progressTimer = null;
            }
        }, 250);
    }

    function stopHeaderProgress() {
        const wrap = document.getElementById('headerProgress');
        const fill = document.getElementById('headerProgressFill');
        if (state.progressTimer) clearInterval(state.progressTimer);
        state.progressTimer = null;
        if (fill) fill.style.width = '100%';
        if (wrap) setTimeout(()=>wrap.classList.add('hidden'), 500);
    }

    function toggleSidebar() {
        document.body.classList.toggle('sidebar-collapsed');
    }

    function openSidebar() {
        document.body.classList.remove('sidebar-collapsed');
    }

    async function regenerateScenario() {
        const btn = document.getElementById('regenerateBtn');
        if (btn) {
            btn.disabled = true;
            btn.textContent = '‚Üª Generating...';
        }
        try {
            await startScenario();
        } finally {
            if (btn) {
                btn.disabled = false;
                btn.textContent = '‚Üª Regenerate';
            }
        }
    }

    function delay(ms){ return new Promise(res=>setTimeout(res, ms)); }

    async function verifyTokenWithWorker(token){
        try {
            const resp = await fetch(`${CF_BASE}/api/verify-token`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ token })
            });
            const data = await resp.json().catch(()=>({}));
            if (!resp.ok) {
                const msg = data.message || `HTTP ${resp.status}`;
                throw new Error(msg);
            }
            return { ok: true, username: data.username || 'unknown' };
        } catch (err) {
            return { ok: false, error: err.message || String(err) };
        }
    }

    function extractAndValidateJSON(rawText) {
        if (!rawText) return null;

        let jsonStr = null;
        const firstBrace = rawText.indexOf('{');
        const lastBrace = rawText.lastIndexOf('}');
        
        if (firstBrace !== -1 && lastBrace !== -1 && firstBrace < lastBrace) {
            jsonStr = rawText.substring(firstBrace, lastBrace + 1);
        }

        if (!jsonStr) return null;

        try {
            const parsed = JSON.parse(jsonStr);
            
            if (!parsed.title) {
                parsed.title = 'Generated Scenario';
            }
            if (!parsed.stages || !Array.isArray(parsed.stages)) {
                return null;
            }
            if (parsed.stages.length === 0) {
                return null;
            }

            return parsed;
        } catch (err) {
            addTerminalLine('error', `[!] JSON parse error: ${err.message}`);
            return null;
        }
    }

    async function generateAIScenario() {
        try {
        addTerminalLine('info', '[*] Generating AI-powered scenario...');
        addTerminalLine('info', '[*] Sending request to generation service...');

            const token = localStorage.getItem('hf_token');
            if (!token) throw new Error('No API token configured. Click ‚öôÔ∏è Settings to add your HF_TOKEN');

            const prompt = buildAIPrompt(state.difficulty, state.topic, state.os);
            
            const payload = {
                model: "openai/gpt-oss-120b:novita",
                messages: [
                    { role: "user", content: prompt }
                ],
                max_tokens: 3500,
                temperature: 0.2
            };

            const resp = await fetch(`${CF_BASE}/api/generate-scenario`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ token, payload })
            });

            const data = await resp.json().catch(()=>({}));

            if (!resp.ok || data.error) {
                const errMsg = data.message || `HTTP ${resp.status}`;
                addTerminalLine('error', `[!] Generation service error: ${errMsg}`);
                throw new Error(errMsg);
            }

            addTerminalLine('success', '[‚úì] Received response from generation service');

            let rawText = null;
            if (Array.isArray(data.choices) && data.choices.length > 0) {
                const first = data.choices[0];
                if (first.message && typeof first.message.content === 'string') rawText = first.message.content;
                else if (typeof first.text === 'string') rawText = first.text;
            }

            if (!rawText) {
                addTerminalLine('error', '[!] Could not locate textual content in model response');
                throw new Error('No model content found');
            }

            rawText = sanitizeModelText(rawText);
            addTerminalLine('info', '[*] Parsing JSON response from model...');

            const scenarioData = extractAndValidateJSON(rawText);
            
            if (!scenarioData) {
                addTerminalLine('error', '[!] Failed to extract valid scenario from model output');
                throw new Error('Invalid scenario structure');
            }

            scenarioData.stages = scenarioData.stages.map((stage, idx) => {
                const s = Object.assign({}, stage);
                s.stageNumber = s.stageNumber || (idx + 1);
                s.name = s.name || `Stage ${idx + 1}`;
                s.objective = s.objective || s.question || 'Complete this stage';
                if (Array.isArray(s.expectedCommands)) {
                    s.expectedCommands = s.expectedCommands;
                } else if (s.expectedCommands) {
                    s.expectedCommands = [s.expectedCommands];
                } else if (s.answer) {
                    s.expectedCommands = [s.answer];
                } else {
                    s.expectedCommands = [''];
                }
                s.commandVariations = Array.isArray(s.commandVariations) ? s.commandVariations : [];
                s.hints = Array.isArray(s.hints) ? s.hints : (s.hints ? [s.hints] : []);
                while (s.hints.length < 3) s.hints.push('No more hints available for this stage.');
                s.commonMistakes = Array.isArray(s.commonMistakes) ? s.commonMistakes : [];
                s.output = s.output || s.response || 'Command executed successfully.';
                s.commandExplanation = s.commandExplanation || '';
                if (Array.isArray(s.expectedFlags)) {
                    s.expectedFlags = s.expectedFlags;
                } else if (s.expectedFlags) {
                    s.expectedFlags = [s.expectedFlags];
                } else {
                    s.expectedFlags = [];
                }
                s.successCriteria = s.successCriteria || '';
                s.securityImplications = s.securityImplications || '';
                s.nextStageSummary = s.nextStageSummary || s.nextStageHint || '';
                return s;
            });

            scenarioData.osType = (scenarioData.osType || state.os).toLowerCase();

            state.scenario = scenarioData;
            state.isAIGenerated = true;
            state.isFallback = false;
            addTerminalLine('success', '[‚úì] AI scenario generated and loaded');
            addTerminalLine('success', `[‚úì] Scenario: ${scenarioData.title}`);
            addTerminalLine('success', `[‚úì] Stages: ${scenarioData.stages.length}`);
            return true;
        } catch (err) {
            addTerminalLine('error', `[!] AI generation failed: ${err.message || err}`);
            addTerminalLine('info', '[*] Will attempt fallback to local template scenario');
            return false;
        }
    }

    function normalizeCommand(cmd) {
        return cmd
            .toLowerCase()
            .replace(/["'`]/g, '')
            .replace(/\s+/g, ' ')
            .trim();
    }

    function commandKeywords(cmd) {
        return normalizeCommand(cmd).split(' ').filter(w => w.length >= 2);
    }

    function commandMatches(userCommand, expectedCommand, difficulty) {
        const u = normalizeCommand(userCommand);
        const e = normalizeCommand(expectedCommand);
        return u === e;
    }

    function findClosestVariation(userCmd, stage) {
        const u = normalizeCommand(userCmd);
        for (const v of stage.commandVariations || []) {
            const base = normalizeCommand(v.command);
            if (u.includes(base.split(' ')[0])) return v;
            for (const alt of v.variations || []) {
                if (u.includes(normalizeCommand(alt))) return v;
            }
        }
        for (const expected of stage.expectedCommands || []) {
            const base = normalizeCommand(expected).split(' ')[0];
            if (u.includes(base)) return { command: base, variations: [], description: 'matches tool' };
        }
        return null;
    }

    function getStageAnswer(stage) {
        if (!stage) return '';
        if (stage.answer) return String(stage.answer);
        if (Array.isArray(stage.expectedCommands) && stage.expectedCommands[0]) return String(stage.expectedCommands[0]);
        return '';
    }

    function extractPortFromText(text) {
        if (!text) return '';
        const raw = String(text);
        if (/<\s*port/i.test(raw)) return '<port>';
        let match = raw.match(/-p\s*([0-9]{2,5})/i);
        if (match) return match[1];
        match = raw.match(/:(\d{2,5})/);
        if (match) return match[1];
        match = raw.match(/\s([0-9]{2,5})\s*$/);
        if (match) return match[1];
        return '';
    }

    function updateTargetInfo(stage) {
        const targetEl = document.getElementById('targetInfo');
        if (!targetEl || !state.scenario || !state.scenario.targetIP) {
            if (targetEl) targetEl.classList.add('hidden');
            return;
        }

        const ip = state.scenario.targetIP;
        const answer = getStageAnswer(stage);
        const needsPort = /port/i.test(stage.question || stage.objective || '') || /-p\s*\d+|:\d{2,5}/.test(answer);
        const port = extractPortFromText(stage.question) || extractPortFromText(answer);

        const parts = [`IP: ${ip}`];
        if (needsPort) parts.push(`Port: ${port || 'see question'}`);

        targetEl.textContent = parts.join(' | ');
        targetEl.classList.remove('hidden');
    }

    function updateSectionInfo() {
        const sectionEl = document.getElementById('sectionInfo');
        if (!sectionEl) return;
        if (!state.currentSection) {
            sectionEl.classList.add('hidden');
            return;
        }
        sectionEl.textContent = `Section: ${state.currentSection}`;
        sectionEl.classList.remove('hidden');
    }

    function executeCommand() {
        const input = document.getElementById('commandInput');
        const command = input.value.trim();
        if (!command) return;

        if (command.toLowerCase() === 'answer') {
            showAnswer();
            input.value = '';
            return;
        }

        addTerminalLine('', `<span class="prompt">$</span><span class="command">${escapeHtml(command)}</span>`);
        state.commandCount++;
        document.getElementById('cmdCount').textContent = state.commandCount;

        const stage = state.scenario.stages[state.currentStage];
        const stageIndex = state.currentStage;
        const expectedCommands = stage.expectedCommands || [];

        const isCorrect = expectedCommands.some(exp => commandMatches(command, exp, state.difficulty)) ||
                          (stage.commandVariations || []).some(cv => {
                              if (commandMatches(command, cv.command, state.difficulty)) return true;
                              return (cv.variations || []).some(v => commandMatches(command, v, state.difficulty));
                          });

        if (isCorrect) {
            const output = stage.output || '';
            addTerminalLine('output', `<pre style="white-space:pre-wrap">${escapeHtml(output)}</pre>`);

            addTerminalLine('success', '‚úì Correct!');
            if (stage.securityImplications) addTerminalLine('info', `<strong>Security:</strong> ${escapeHtml(stage.securityImplications)}`);
            if (stage.commonMistakes && stage.commonMistakes.length > 0) addTerminalLine('info', `<strong>Common Mistakes:</strong> ${escapeHtml(stage.commonMistakes.join('; '))}`);
            if (state.guidanceMode === 'guided' && stage.commandExplanation) {
                addTerminalLine('info', `<strong>Command Explanation:</strong> ${escapeHtml(stage.commandExplanation)}`);
            }

            state.completedStages.push(state.currentStage);
            state.currentStage++;
            setTimeout(()=>{
                if (state.currentStage < state.scenario.stages.length) {
                    addTerminalLine('', '');
                    const next = state.scenario.stages[state.currentStage];
                    if (next && next.nextStageSummary) addTerminalLine('info', `Next: ${escapeHtml(next.nextStageSummary)}`);
                    showCurrentStage();
                } else {
                    completeScenario();
                }
            }, 900);
        } else {
            if (state.wrongAttempts[stageIndex] === undefined) state.wrongAttempts[stageIndex] = 0;
            state.wrongAttempts[stageIndex] += 1;

            const close = findClosestVariation(command, stage);
            if (close) {
                addTerminalLine('error', `Command not recognized or incorrect. Tool looks correct (${escapeHtml(close.command)}). Try variants: ${escapeHtml((close.variations||[]).slice(0,3).join(', ') || close.description || '')}`);
            } else {
                addTerminalLine('error', 'Command not recognized or incorrect. Try again or type "hint" for guidance.');
            }
            if (stage.hints && stage.hints.length > 0) {
                addTerminalLine('info', 'Type "hint" for guidance');
            }
            if (state.wrongAttempts[stageIndex] >= 3 && !state.revealEnabled[stageIndex]) {
                state.revealEnabled[stageIndex] = true;
                addTerminalLine('info', 'Type "answer" to reveal the expected command.');
            }
        }
        input.value = '';
    }

    async function startScenario() {
        document.getElementById('commandInput').disabled = true;
        document.getElementById('submitBtn').disabled = true;
        document.getElementById('terminal').innerHTML = '';
        document.body.classList.add('sidebar-collapsed');

        state.loadingPhase = true;
        addTerminalLine('info', '[*] noo vm Lab Machine Starting...');
        addTerminalLine('info', `[*] OS: ${state.os.toUpperCase()}`);
        addTerminalLine('info', '[*] Initializing virtual environment...');
        await delay(300);
        addTerminalLine('info', '[*] Generating scenario... please wait ~5 seconds');
        startHeaderProgress(40000);

        const aiOk = await generateAIScenario();
        state.loadingPhase = false;
        stopHeaderProgress();

        if (!aiOk) {
            state.scenario = null;
            state.isAIGenerated = false;
            state.isFallback = true;
            document.getElementById('terminal').innerHTML = '';
            addTerminalLine('info', '[!] AI token not found or generation failed. Add your HF token in Settings:');
            addTerminalLine('info', '1) Create a free Hugging Face account');
            addTerminalLine('info', '2) Go to <a href="https://huggingface.co/settings/tokens" target="_blank" rel="noopener noreferrer" style="color:#06b6d4;text-decoration:underline">https://huggingface.co/settings/tokens</a>');
            addTerminalLine('info', '3) Click "New token"');
            addTerminalLine('info', '4) Click "Read"');
            addTerminalLine('info', '5) Click "Create Token"');
            addTerminalLine('info', '6) Copy the token (starts with hf_) and paste it in Settings');
            document.getElementById('commandInput').disabled = true;
            document.getElementById('submitBtn').disabled = true;
            updateHeader();
            return;
        }

        state.currentStage = 0;
        state.commandCount = 0;
        state.completedStages = [];
        state.wrongAttempts = {};
        state.revealEnabled = {};
        state.answerRevealed = {};
        state.startTime = Date.now();
        state.active = true;

        document.getElementById('commandInput').disabled = false;
        document.getElementById('submitBtn').disabled = false;
        document.getElementById('inputWrapper').classList.add('active');

        setTimeout(()=>{
            addTerminalLine('success', '[‚úì] System online');
            addTerminalLine('success', '[‚úì] Ready for exploitation');
            addTerminalLine('', '');
            updateHeader();
            showCurrentStage();
            document.getElementById('commandInput').focus();
        }, 700);
    }

    function showCurrentStage() {
        if (!state.scenario) {
            addTerminalLine('error', '[!] No scenario loaded');
            return;
        }
        clearStartupLogs();
        if (state.currentStage >= state.scenario.stages.length) {
            completeScenario();
            return;
        }
        const stage = state.scenario.stages[state.currentStage];
        addTerminalLine('', '<div class="stage-divider"></div>');
        addTerminalLine('info', `[Stage ${state.currentStage + 1}/${state.scenario.stages.length}] ${stage.name}`);
        addTerminalLine('info', `Objective: ${stage.objective}`);
        if (stage.question) addTerminalLine('info question-line', `Question: ${escapeHtml(stage.question)}`);
        let contextShown = false;
        if (stage.question) {
            const ctxParts = [];
            const ip = state.scenario && state.scenario.targetIP ? state.scenario.targetIP : '';
            if (ip && /ip|address|host|target|port/i.test(stage.question)) {
                const port = extractPortFromText(stage.question) || extractPortFromText(getStageAnswer(stage));
                ctxParts.push(`Target IP: ${ip}`);
                if (/port/i.test(stage.question) || port) {
                    ctxParts.push(`Port: ${port || 'see question'}`);
                }
            }
            if (ctxParts.length) {
                addTerminalLine('info context-line', `<strong>Context:</strong> ${escapeHtml(ctxParts.join(' | '))}`);
                addTerminalLine('info context-note', 'Note: This is a dummy IP for training (not a real target).');
                contextShown = true;
            }
        }
        const targetEl = document.getElementById('targetInfo');
        if (targetEl) {
            if (contextShown) targetEl.classList.add('hidden');
            else targetEl.classList.remove('hidden');
        }
        addTerminalLine('info', `Hints available: ${stage.hints.length}. Type 'hint' to view.`);
        if (state.guidanceMode === 'guided' && stage.hints && stage.hints.length > 0) {
            addTerminalLine('info', `<strong>Guided Hint:</strong> ${escapeHtml(stage.hints[0])}`);
        }
        const tools = (stage.commandVariations || []).map(cv => cv.command.split(' ')[0]).filter(Boolean);
        if (tools.length) addTerminalLine('info', `Tools: ${escapeHtml([...new Set(tools)].join(', '))}`);
        state.hints = Array.isArray(stage.hints) ? stage.hints : (stage.hints ? [stage.hints] : []);
        state.currentHintIndex = 0;
        state.wrongAttempts[state.currentStage] = 0;
        state.revealEnabled[state.currentStage] = false;
        state.answerRevealed[state.currentStage] = false;
        updateHeader();
        updateTargetInfo(stage);
        updateSectionInfo();
    }

    function updateHeader() {
        if (!state.scenario) {
            const targetEl = document.getElementById('targetInfo');
            if (targetEl) targetEl.classList.add('hidden');
            const sectionEl = document.getElementById('sectionInfo');
            if (sectionEl) sectionEl.classList.add('hidden');
            const progressEl = document.getElementById('headerProgress');
            if (progressEl) progressEl.classList.add('hidden');
            const statsEl = document.getElementById('headerStats');
            if (statsEl) statsEl.classList.add('hidden');
            if (state.isFallback) {
                document.getElementById('headerTitle').textContent = 'Add Hugging Face Free API Key';
                document.getElementById('headerSubtitle').textContent = 'Open Settings to add your token';
                const statusEl = document.getElementById('headerStatus');
                if (statusEl) {
                    statusEl.textContent = '[!] AI token not found or generation failed. Add your HF token in Settings:';
                    statusEl.classList.remove('hidden');
                }
            }
            return;
        }
        const stage = state.scenario.stages[Math.min(state.currentStage, state.scenario.stages.length-1)];
        document.getElementById('headerTitle').textContent = state.scenario ? `Stage ${state.currentStage + 1}: ${stage.name}` : 'noo vm';
        document.getElementById('headerSubtitle').textContent = stage.objective || '';
        document.getElementById('currentStage').textContent = state.currentStage + 1;
        document.getElementById('totalStages').textContent = state.scenario.stages.length;
        const statsEl = document.getElementById('headerStats');
        if (statsEl) {
            document.getElementById('headerStageStat').textContent = `Stage: ${state.currentStage + 1}/${state.scenario.stages.length}`;
            document.getElementById('headerTimeStat').textContent = `Time: ${document.getElementById('elapsed').textContent}`;
            document.getElementById('headerCmdStat').textContent = `Commands: ${state.commandCount}`;
            statsEl.classList.remove('hidden');
        }
        const progress = Math.round((state.currentStage / state.scenario.stages.length) * 100);
        document.getElementById('progressFill').style.width = progress + '%';
    }

    function completeScenario() {
        state.active = false;
        const elapsed = Math.floor((Date.now() - state.startTime) / 1000);
        const minutes = Math.floor(elapsed/60);
        const seconds = elapsed % 60;
        const efficiency = state.commandCount > 0 ? Math.round((state.scenario.stages.length / state.commandCount) * 100) : 100;

        const outcomes = (state.scenario.metadata && state.scenario.metadata.learningOutcomes) ? state.scenario.metadata.learningOutcomes.join(', ') : 'Learned concepts';
        const victoryText = `
<strong>Scenario: ${escapeHtml(state.scenario.title || 'Untitled')}</strong>
<br><br>
You successfully completed all ${state.scenario.stages.length} stages!
<br><br>
<strong>Statistics:</strong>
<br>Time: ${minutes}:${seconds.toString().padStart(2,'0')}
<br>Commands used: ${state.commandCount}
<br>Efficiency: ${efficiency}%
<br><br>
<strong>Learning outcomes:</strong> ${escapeHtml(outcomes)}
<br><br>
<strong>FLAG: SCENARIO_COMPLETE</strong>
`;
        document.getElementById('victoryText').innerHTML = victoryText;
        document.getElementById('victoryModal').classList.add('active');
        document.getElementById('commandInput').disabled = true;
        document.getElementById('inputWrapper').classList.remove('active');
    }

    function showHint() {
        if (!state.hints || state.hints.length === 0) {
            addTerminalLine('info', 'No hints available for this stage');
            return;
        }
        if (state.currentHintIndex >= state.hints.length) state.currentHintIndex = 0;
        const hint = state.hints[state.currentHintIndex];
        document.getElementById('hintText').textContent = hint;
        document.getElementById('hintModal').classList.add('active');
    }

    function showAnswer() {
        const stageIndex = state.currentStage;
        const stage = state.scenario && state.scenario.stages ? state.scenario.stages[stageIndex] : null;
        if (!stage) {
            addTerminalLine('info', 'No active stage.');
            return;
        }
        if (!state.revealEnabled[stageIndex]) {
            addTerminalLine('info', 'Answer reveal is locked. Make three attempts first.');
            return;
        }
        if (state.answerRevealed[stageIndex]) {
            addTerminalLine('info', 'Answer already revealed for this stage.');
            return;
        }
        const answer = getStageAnswer(stage);
        if (!answer) {
            addTerminalLine('info', 'No answer available for this stage.');
            return;
        }
        addTerminalLine('info', `<strong>Answer:</strong> ${escapeHtml(answer)}`);
        if (stage.commandExplanation) {
            addTerminalLine('info', `<strong>Explanation:</strong> ${escapeHtml(stage.commandExplanation)}`);
        }
        addTerminalLine('success', 'Type this answer to go into the next stage.');
        state.answerRevealed[stageIndex] = true;
    }

    function closeHint() {
        document.getElementById('hintModal').classList.remove('active');
    }

    function nextHint() {
        state.currentHintIndex++;
        if (!state.hints || state.currentHintIndex >= state.hints.length) {
            document.getElementById('hintText').textContent = 'No more hints available';
        } else {
            document.getElementById('hintText').textContent = state.hints[state.currentHintIndex];
        }
    }

    function updateTimer() {
        if (!state.startTime) return;
        const elapsed = Math.floor((Date.now() - state.startTime) / 1000);
        const minutes = Math.floor(elapsed/60);
        const seconds = elapsed % 60;
        document.getElementById('elapsed').textContent = `${minutes}:${seconds.toString().padStart(2,'0')}`;
        const headerTime = document.getElementById('headerTimeStat');
        if (headerTime) headerTime.textContent = `Time: ${minutes}:${seconds.toString().padStart(2,'0')}`;
    }

    function openSettings(){
        const token = localStorage.getItem('hf_token') || '';
        document.getElementById('hfTokenInput').value = token;
        document.getElementById('settingsModal').classList.add('active');
    }

    function closeSettings(){ document.getElementById('settingsModal').classList.remove('active'); }

    async function saveSettingsHandler(){
        const input = document.getElementById('hfTokenInput');
        const token = input.value.trim();
        if (!token) {
            addTerminalLine('error', '[!] Please enter a valid token');
            return;
        }

        addTerminalLine('info', '[*] Verifying token with service...');
        document.getElementById('saveTokenBtn').disabled = true;
        try {
            const result = await verifyTokenWithWorker(token);
            if (!result.ok) {
                addTerminalLine('error', `[!] Token verification failed: ${result.error}`);
                document.getElementById('saveTokenBtn').disabled = false;
                return;
            }
            localStorage.setItem('hf_token', token);
            addTerminalLine('success', `[‚úì] Token verified for user: ${result.username}. Token saved.`);
            closeSettings();
            return;
        } catch (err) {
            addTerminalLine('error', `[!] Verification error: ${err.message || err}`);
        } finally {
            document.getElementById('saveTokenBtn').disabled = false;
        }
    }

    function updateButtonVisibility() {
        const startMachineSection = document.getElementById('startMachineSection');
        startMachineSection.classList.remove('hidden');
    }

    document.querySelectorAll('[data-os]').forEach(btn => {
        btn.addEventListener('click', (e)=>{
            document.querySelectorAll('[data-os]').forEach(b=>b.classList.remove('active'));
            e.target.classList.add('active');
            state.os = e.target.dataset.os;
            const isAdvanced = state.difficulty === 'advanced' || state.difficulty === 'expert';
            const isWindows = state.os === 'windows';
            document.querySelectorAll('[data-topic="ad"]').forEach(b=>{
                if (isWindows) b.classList.remove('hidden');
                else b.classList.add('hidden');
            });
            document.querySelectorAll('[data-topic="winrecon"]').forEach(b=>{
                if (isWindows) b.classList.remove('hidden');
                else b.classList.add('hidden');
            });
            document.querySelectorAll('[data-topic="wireless"]').forEach(b=>{
                if (isAdvanced) b.classList.remove('hidden');
                else b.classList.add('hidden');
            });
            updateButtonVisibility();
        });
    });

    document.querySelectorAll('[data-guidance]').forEach(btn => {
        btn.addEventListener('click', (e)=>{
            document.querySelectorAll('[data-guidance]').forEach(b=>b.classList.remove('active'));
            e.target.classList.add('active');
            state.guidanceMode = e.target.dataset.guidance;
            state.difficulty = state.guidanceMode === 'challenge' ? 'advanced' : 'beginner';
            const isAdvanced = state.difficulty === 'advanced' || state.difficulty === 'expert';
            const isWindows = state.os === 'windows';
            document.querySelectorAll('[data-topic="ad"]').forEach(b=>{
                if (isWindows) b.classList.remove('hidden');
                else b.classList.add('hidden');
            });
            document.querySelectorAll('[data-topic="winrecon"]').forEach(b=>{
                if (isWindows) b.classList.remove('hidden');
                else b.classList.add('hidden');
            });
            document.querySelectorAll('[data-topic="wireless"]').forEach(b=>{
                if (isAdvanced) b.classList.remove('hidden');
                else b.classList.add('hidden');
            });
            updateButtonVisibility();
        });
    });

    document.querySelectorAll('[data-topic]').forEach(btn => {
        btn.addEventListener('click', (e)=>{
            document.querySelectorAll('[data-topic]').forEach(b=>b.classList.remove('active'));
            e.target.classList.add('active');
            state.topic = e.target.dataset.topic;
            updateButtonVisibility();
        });
    });

    (function syncAdvancedTopicsOnLoad(){
        const isAdvanced = state.difficulty === 'advanced' || state.difficulty === 'expert';
        const isWindows = state.os === 'windows';
        document.querySelectorAll('[data-topic="ad"]').forEach(b=>{
            if (isWindows) b.classList.remove('hidden');
            else b.classList.add('hidden');
        });
        document.querySelectorAll('[data-topic="winrecon"]').forEach(b=>{
            if (isWindows) b.classList.remove('hidden');
            else b.classList.add('hidden');
        });
        document.querySelectorAll('[data-topic="wireless"]').forEach(b=>{
            if (isAdvanced) b.classList.remove('hidden');
            else b.classList.add('hidden');
        });
    })();

    document.getElementById('startMachineBtn').addEventListener('click', async ()=>{
        const machineBtn = document.getElementById('startMachineBtn');
        machineBtn.disabled = true;
        machineBtn.textContent = 'üñ•Ô∏è Starting Machine...';
        document.getElementById('startMachineSection').classList.add('hidden');
        document.getElementById('progressSection').classList.remove('hidden');

        setTimeout(async ()=>{
            try {
                await startScenario();
            } finally {
                machineBtn.disabled = false;
                machineBtn.textContent = 'üñ•Ô∏è Start Machine';
            }
        }, 800);
    });

    document.getElementById('settingsBtn').addEventListener('click', openSettings);
    document.getElementById('mobileToggleBtn').addEventListener('click', toggleSidebar);
    document.getElementById('regenerateBtn').addEventListener('click', regenerateScenario);
    document.getElementById('saveTokenBtn').addEventListener('click', saveSettingsHandler);
    document.getElementById('submitBtn').addEventListener('click', executeCommand);
    document.getElementById('commandInput').addEventListener('keypress', (e)=>{ if (e.key === 'Enter') executeCommand(); });
    document.querySelector('.input-area').addEventListener('submit', (e)=>{ e.preventDefault(); executeCommand(); });

    document.getElementById('commandInput').addEventListener('input', (e)=>{
        const val = e.target.value.toLowerCase();
        if (val.includes('hint')) {
            e.target.value = e.target.value.replace(/hint/gi, '');
            showHint();
            return;
        }
        if (val.includes('answer')) {
            e.target.value = e.target.value.replace(/answer/gi, '');
            showAnswer();
        }
    });

    setInterval(updateTimer, 1000);

    function escapeHtml(unsafe) {
        if (unsafe === null || unsafe === undefined) return '';
        return String(unsafe)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/\"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    window.showHint = showHint;
    window.closeHint = closeHint;
    window.nextHint = nextHint;
    window.closeSettings = closeSettings;
    window.openSettings = openSettings;

    console.log('noo vm Platform: Robust JSON parsing, improved error handling, fallback support');
    </script>
</body>
</html>
